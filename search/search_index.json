{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\ud83c\udf84\ud83c\udf84\ud83c\udf84 Advent of code \u00b6 You will find in this website daily coding challenges and proposed solutions. It will also highlight some programming best practices and tricks Note Coding challenges are drawn from the awesome platform Advent Of Code . This website is merely a wrapper of our open source solutions and tricks \u27a1 Go to the challenges tab to get started","title":"\ud83c\udf84\ud83c\udf84\ud83c\udf84 Advent of code"},{"location":"#advent-of-code","text":"You will find in this website daily coding challenges and proposed solutions. It will also highlight some programming best practices and tricks Note Coding challenges are drawn from the awesome platform Advent Of Code . This website is merely a wrapper of our open source solutions and tricks \u27a1 Go to the challenges tab to get started","title":"\ud83c\udf84\ud83c\udf84\ud83c\udf84 Advent of code"},{"location":"tutorials/day2/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Day 2: Password Philosophy \u00b6 Problem \u00b6 Note Your flight departs in a few days from the coastal airport; the easiest way down to the coast from here is via toboggan. The shopkeeper at the North Pole Toboggan Rental Shop is having a bad day. \"Something's wrong with our computers; we can't log in!\" You ask if you can take a look. Their password database seems to be a little corrupted: some of the passwords wouldn't have been allowed by the Official Toboggan Corporate Policy that was in effect when they were chosen. To try to debug the problem, they have created a list (your puzzle input) of passwords (according to the corrupted database) and the corporate policy when that password was set. For example, suppose you have the following list: 1-3 a: abcde 1-3 b: cdefg 2-9 c: ccccccccc Each line gives the password policy and then the password. The password policy indicates the lowest and highest number of times a given letter must appear for the password to be valid. For example, 1-3 a means that the password must contain a at least 1 time and at most 3 times. In the above example, 2 passwords are valid. The middle password, cdefg, is not; it contains no instances of b, but needs at least 1. The first and third passwords are valid: they contain one a or nine c, both within the limits of their respective policies. How many passwords are valid according to their policies? https://adventofcode.com/2020/day/2 Solution 1 \u00b6 Tip \u00b6 You can use the Counter algorithms, it's native to Python, you have nothing to install from collections import Counter Counter ( \"aabebeheucuefh\" ) Counter({'a': 2, 'b': 2, 'e': 4, 'h': 2, 'u': 2, 'c': 1, 'f': 1}) Counter ( \"aabebeheucuefh\" ) . get ( \"a\" , 0 ) 2 Counter ( \"aabebeheucuefh\" ) . get ( \"z\" , 0 ) 0 Writing the solution functions \u00b6 def split_policy_password ( x ): \"\"\"Splits input strings with policy and password provided by the platform Returns policy and password in a tuple \"\"\" policy , password = x . split ( \":\" ) return policy . strip (), password . strip () def is_valid ( x ): policy , password = split_policy_password ( x ) minmax , letter = policy . split ( \" \" ) min_value , max_value = minmax . split ( \"-\" ) min_value , max_value = int ( min_value ), int ( max_value ) count = Counter ( password ) return min_value <= count . get ( letter , 0 ) <= max_value def count_valids ( text_input ): examples = text_input . strip () . split ( \" \\n \" ) valids = [ x for x in examples if is_valid ( x )] return len ( valids ) Solving the example \u00b6 text_input = \"\"\" 1-3 a: abcde 1-3 b: cdefg 2-9 c: ccccccccc \"\"\" examples = text_input . strip () . split ( \" \\n \" ) for x in examples : print ( x , \" - \" , is_valid ( x )) 1-3 a: abcde - True 1-3 b: cdefg - False 2-9 c: ccccccccc - True count_valids ( text_input ) 2 Solving the final solution \u00b6 text_input = open ( \"inputs/day2.txt\" , \"r\" ) . read () print ( text_input [: 500 ]) 3-11 z: zzzzzdzzzzlzz 3-7 x: xjxbgpxxgtx 3-4 v: vvmv 3-5 t: tgkfq 9-10 j: jjjjjjjjqjjjj 5-7 r: rnhrhrr 2-6 n: gnntnnsnnqjsbrn 3-4 g: vrggfvxsgmggkgsm 1-4 c: brccqr 1-5 h: hhhzzvcdhhhhhhhh 4-11 c: ncnqbzlkckc 1-13 q: hqqqqqqqqqqqlq 8-9 h: hhhhhhxxkh 3-9 b: bbbbsfbbc 3-8 k: zfqzkzgk 3-9 k: wjkwhnkkfvxk 3-11 v: vgkvvcjvvvv 5-6 l: llllhr 9-11 z: lzzzgzzmzzdzzz 13-16 w: wwlwwwwlwwxwwfwf 8-11 r: rrrrrrrrrrcrdrr 1-9 v: mlvvvxnwrwvv 4-6 z: mzzzzz 3-4 s: svsj 8-11 w: wwwwwwwjwwww 10-13 r: drrrrzhmxfjdrtf count_valids ( text_input ) 550 Solution 2 \u00b6 import re valid_passwords = [] valid_passwords_part_two = [] with open ( './day-2-input.txt' , 'r' ) as f : for l in f . readlines (): # Parse line with regular expression n_min , n_max , letter , password = re . match ( r \"(\\d+)-(\\d+) (\\w): (\\w+)\" , l ) . groups () # Part one if int ( n_min ) <= len ( re . findall ( letter , password )) <= int ( n_max ): valid_passwords . append ( password ) # Part two, using Python's XOR operator if ( password [ int ( n_min ) - 1 ] == letter ) ^ ( password [ int ( n_max ) - 1 ] == letter ): valid_passwords_part_two . append ( password ) # Answer to part one len ( valid_passwords ) # Answer to part two len ( valid_passwords_part_two )","title":"Day 2"},{"location":"tutorials/day2/#day-2-password-philosophy","text":"","title":"Day 2: Password Philosophy"},{"location":"tutorials/day2/#problem","text":"Note Your flight departs in a few days from the coastal airport; the easiest way down to the coast from here is via toboggan. The shopkeeper at the North Pole Toboggan Rental Shop is having a bad day. \"Something's wrong with our computers; we can't log in!\" You ask if you can take a look. Their password database seems to be a little corrupted: some of the passwords wouldn't have been allowed by the Official Toboggan Corporate Policy that was in effect when they were chosen. To try to debug the problem, they have created a list (your puzzle input) of passwords (according to the corrupted database) and the corporate policy when that password was set. For example, suppose you have the following list: 1-3 a: abcde 1-3 b: cdefg 2-9 c: ccccccccc Each line gives the password policy and then the password. The password policy indicates the lowest and highest number of times a given letter must appear for the password to be valid. For example, 1-3 a means that the password must contain a at least 1 time and at most 3 times. In the above example, 2 passwords are valid. The middle password, cdefg, is not; it contains no instances of b, but needs at least 1. The first and third passwords are valid: they contain one a or nine c, both within the limits of their respective policies. How many passwords are valid according to their policies? https://adventofcode.com/2020/day/2","title":"Problem"},{"location":"tutorials/day2/#solution-1","text":"","title":"Solution 1"},{"location":"tutorials/day2/#tip","text":"You can use the Counter algorithms, it's native to Python, you have nothing to install from collections import Counter Counter ( \"aabebeheucuefh\" ) Counter({'a': 2, 'b': 2, 'e': 4, 'h': 2, 'u': 2, 'c': 1, 'f': 1}) Counter ( \"aabebeheucuefh\" ) . get ( \"a\" , 0 ) 2 Counter ( \"aabebeheucuefh\" ) . get ( \"z\" , 0 ) 0","title":"Tip"},{"location":"tutorials/day2/#writing-the-solution-functions","text":"def split_policy_password ( x ): \"\"\"Splits input strings with policy and password provided by the platform Returns policy and password in a tuple \"\"\" policy , password = x . split ( \":\" ) return policy . strip (), password . strip () def is_valid ( x ): policy , password = split_policy_password ( x ) minmax , letter = policy . split ( \" \" ) min_value , max_value = minmax . split ( \"-\" ) min_value , max_value = int ( min_value ), int ( max_value ) count = Counter ( password ) return min_value <= count . get ( letter , 0 ) <= max_value def count_valids ( text_input ): examples = text_input . strip () . split ( \" \\n \" ) valids = [ x for x in examples if is_valid ( x )] return len ( valids )","title":"Writing the solution functions"},{"location":"tutorials/day2/#solving-the-example","text":"text_input = \"\"\" 1-3 a: abcde 1-3 b: cdefg 2-9 c: ccccccccc \"\"\" examples = text_input . strip () . split ( \" \\n \" ) for x in examples : print ( x , \" - \" , is_valid ( x )) 1-3 a: abcde - True 1-3 b: cdefg - False 2-9 c: ccccccccc - True count_valids ( text_input ) 2","title":"Solving the example"},{"location":"tutorials/day2/#solving-the-final-solution","text":"text_input = open ( \"inputs/day2.txt\" , \"r\" ) . read () print ( text_input [: 500 ]) 3-11 z: zzzzzdzzzzlzz 3-7 x: xjxbgpxxgtx 3-4 v: vvmv 3-5 t: tgkfq 9-10 j: jjjjjjjjqjjjj 5-7 r: rnhrhrr 2-6 n: gnntnnsnnqjsbrn 3-4 g: vrggfvxsgmggkgsm 1-4 c: brccqr 1-5 h: hhhzzvcdhhhhhhhh 4-11 c: ncnqbzlkckc 1-13 q: hqqqqqqqqqqqlq 8-9 h: hhhhhhxxkh 3-9 b: bbbbsfbbc 3-8 k: zfqzkzgk 3-9 k: wjkwhnkkfvxk 3-11 v: vgkvvcjvvvv 5-6 l: llllhr 9-11 z: lzzzgzzmzzdzzz 13-16 w: wwlwwwwlwwxwwfwf 8-11 r: rrrrrrrrrrcrdrr 1-9 v: mlvvvxnwrwvv 4-6 z: mzzzzz 3-4 s: svsj 8-11 w: wwwwwwwjwwww 10-13 r: drrrrzhmxfjdrtf count_valids ( text_input ) 550","title":"Solving the final solution"},{"location":"tutorials/day2/#solution-2","text":"import re valid_passwords = [] valid_passwords_part_two = [] with open ( './day-2-input.txt' , 'r' ) as f : for l in f . readlines (): # Parse line with regular expression n_min , n_max , letter , password = re . match ( r \"(\\d+)-(\\d+) (\\w): (\\w+)\" , l ) . groups () # Part one if int ( n_min ) <= len ( re . findall ( letter , password )) <= int ( n_max ): valid_passwords . append ( password ) # Part two, using Python's XOR operator if ( password [ int ( n_min ) - 1 ] == letter ) ^ ( password [ int ( n_max ) - 1 ] == letter ): valid_passwords_part_two . append ( password ) # Answer to part one len ( valid_passwords ) # Answer to part two len ( valid_passwords_part_two )","title":"Solution 2"},{"location":"tutorials/day3/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Day 3: Toboggan Trajectory \u00b6 Problem \u00b6 Note With the toboggan login problems resolved, you set off toward the airport. While travel by toboggan might be easy, it's certainly not safe: there's very minimal steering and the area is covered in trees. You'll need to see which angles will take you near the fewest trees. Due to the local geology, trees in this area only grow on exact integer coordinates in a grid. You make a map (your puzzle input) of the open squares (.) and trees (#) you can see. For example: ..##....... #...#...#.. .#....#..#. ..#.#...#.# .#...##..#. ..#.##..... .#.#.#....# .#........# #.##...#... #...##....# .#..#...#.# These aren't the only trees, though; due to something you read about once involving arboreal genetics and biome stability, the same pattern repeats to the right many times ..##.........##.........##.........##.........##.........##....... ---> #...#...#..#...#...#..#...#...#..#...#...#..#...#...#..#...#...#.. .#....#..#..#....#..#..#....#..#..#....#..#..#....#..#..#....#..#. ..#.#...#.#..#.#...#.#..#.#...#.#..#.#...#.#..#.#...#.#..#.#...#.# .#...##..#..#...##..#..#...##..#..#...##..#..#...##..#..#...##..#. ..#.##.......#.##.......#.##.......#.##.......#.##.......#.##..... ---> .#.#.#....#.#.#.#....#.#.#.#....#.#.#.#....#.#.#.#....#.#.#.#....# .#........#.#........#.#........#.#........#.#........#.#........# #.##...#...#.##...#...#.##...#...#.##...#...#.##...#...#.##...#... #...##....##...##....##...##....##...##....##...##....##...##....# .#..#...#.#.#..#...#.#.#..#...#.#.#..#...#.#.#..#...#.#.#..#...#.# ---> You start on the open square (.) in the top-left corner and need to reach the bottom (below the bottom-most row on your map). The toboggan can only follow a few specific slopes (you opted for a cheaper model that prefers rational numbers); start by counting all the trees you would encounter for the slope right 3, down 1: From your starting position at the top-left, check the position that is right 3 and down 1. Then, check the position that is right 3 and down 1 from there, and so on until you go past the bottom of the map. The locations you'd check in the above example are marked here with O where there was an open square and X where there was a tree: ..##.........##.........##.........##.........##.........##....... ---> #..O#...#..#...#...#..#...#...#..#...#...#..#...#...#..#...#...#.. .#....X..#..#....#..#..#....#..#..#....#..#..#....#..#..#....#..#. ..#.#...#O#..#.#...#.#..#.#...#.#..#.#...#.#..#.#...#.#..#.#...#.# .#...##..#..X...##..#..#...##..#..#...##..#..#...##..#..#...##..#. ..#.##.......#.X#.......#.##.......#.##.......#.##.......#.##..... ---> .#.#.#....#.#.#.#.O..#.#.#.#....#.#.#.#....#.#.#.#....#.#.#.#....# .#........#.#........X.#........#.#........#.#........#.#........# #.##...#...#.##...#...#.X#...#...#.##...#...#.##...#...#.##...#... #...##....##...##....##...#X....##...##....##...##....##...##....# .#..#...#.#.#..#...#.#.#..#...X.#.#..#...#.#.#..#...#.#.#..#...#.# ---> In this example, traversing the map using this slope would cause you to encounter 7 trees. Starting at the top-left corner of your map and following a slope of right 3 and down 1, how many trees would you encounter? https://adventofcode.com/2020/day/3 Solution 1 \u00b6 Tip \u00b6 You can use numpy here to avoid doing loops. Using For loops here would work, but it would not be scalable when the size of the grid grows. If you apply only numpy vectorization operations, it's a little more complicated but you are almost instantly scalable. import numpy as np Writing the solution functions \u00b6 def solve_problem ( text_input : str , slope : tuple ) -> int : # Transform the text input to a list of list of characters text_array = text_input . strip () . split ( \" \\n \" ) text_array = list ( map ( list , text_array )) # Prepare and vectorize the slope with numpy slope = np . array ( slope ) . reshape ( - 1 , 1 ) # Convert to a matrix of 1 and 0s matrix = np . int8 ( np . array ( text_array ) == \"#\" ) # Find the number of iterations to traverse vertically with a given slope iterations = matrix . shape [ 0 ] / slope_coefs [ 0 ] # Directly find the coordinates for each points index = slope * np . arange ( iterations )[ np . newaxis ,:] . repeat ( 2 , axis = 0 ) # As the patterns repeats, we could reproduce the grid horizontally # But algorithmically we can just use division with rest # it will simulate that when you go out of the grid, you reappear to the left index [ 1 ] = index [ 1 ] % matrix . shape [ 1 ] index = index . astype ( int ) # Select directly the cells in the slope selection = matrix [ tuple ( index )] # Sum all values (1s if trees) to get the number on the slope return np . sum ( selection ) Solving the example \u00b6 x = \"\"\" ..##.........##.........##.........##.........##.........##....... #...#...#..#...#...#..#...#...#..#...#...#..#...#...#..#...#...#.. .#....#..#..#....#..#..#....#..#..#....#..#..#....#..#..#....#..#. ..#.#...#.#..#.#...#.#..#.#...#.#..#.#...#.#..#.#...#.#..#.#...#.# .#...##..#..#...##..#..#...##..#..#...##..#..#...##..#..#...##..#. ..#.##.......#.##.......#.##.......#.##.......#.##.......#.##..... .#.#.#....#.#.#.#....#.#.#.#....#.#.#.#....#.#.#.#....#.#.#.#....# .#........#.#........#.#........#.#........#.#........#.#........# #.##...#...#.##...#...#.##...#...#.##...#...#.##...#...#.##...#... #...##....##...##....##...##....##...##....##...##....##...##....# .#..#...#.#.#..#...#.#.#..#...#.#.#..#...#.#.#..#...#.#.#..#...#.# \"\"\" print ( x ) text_array = x . strip () . split ( \" \\n \" ) text_array = list ( map ( list , text_array )) ..##.........##.........##.........##.........##.........##....... #...#...#..#...#...#..#...#...#..#...#...#..#...#...#..#...#...#.. .#....#..#..#....#..#..#....#..#..#....#..#..#....#..#..#....#..#. ..#.#...#.#..#.#...#.#..#.#...#.#..#.#...#.#..#.#...#.#..#.#...#.# .#...##..#..#...##..#..#...##..#..#...##..#..#...##..#..#...##..#. ..#.##.......#.##.......#.##.......#.##.......#.##.......#.##..... .#.#.#....#.#.#.#....#.#.#.#....#.#.#.#....#.#.#.#....#.#.#.#....# .#........#.#........#.#........#.#........#.#........#.#........# #.##...#...#.##...#...#.##...#...#.##...#...#.##...#...#.##...#... #...##....##...##....##...##....##...##....##...##....##...##....# .#..#...#.#.#..#...#.#.#..#...#.#.#..#...#.#.#..#...#.#.#..#...#.# matrix = np . int8 ( np . array ( text_array ) == \"#\" ) slope_coefs = ( 1 , 3 ) # numpy is ordered differently slope = np . array ( slope_coefs ) . reshape ( - 1 , 1 ) slope array([[1], [3]]) iterations = matrix . shape [ 0 ] / slope_coefs [ 0 ] iterations 11.0 index = slope * np . arange ( iterations )[ np . newaxis ,:] . repeat ( 2 , axis = 0 ) index [ 1 ] = index [ 1 ] % matrix . shape [ 1 ] index = index . astype ( int ) index array([[ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [ 0, 3, 6, 9, 12, 15, 18, 21, 24, 27, 30]]) selection = matrix [ tuple ( index )] np . sum ( selection ) 7 Or using the function solve_problem ( x ,( 1 , 3 )) 7 Solving the final solution \u00b6 text_input = open ( \"inputs/day3.txt\" , \"r\" ) . read () print ( text_input [: 500 ]) .#..............##....#.#.####. ##..........#.....##........... .......#....##...........#.#... .........#.#...#..........#.... .........#..#................## ..#...#..#..#...........#...... ...................#...##..##.. ........#.....##...#.#.#...#... #..#.##......#.#..#..........#. ......#.#...#.#...#........##.# .....#.####........#........... ...###..#............#......... .....#.......##......#...#..... #......##...................... ......#..............#......... ..##...#....###.##.. solve_problem ( text_input ,( 1 , 3 )) 193 Solution 2 \u00b6 import numpy as np # Load matrix from file matrix = [] with open ( 'inputs/day3.txt' , 'r' ) as f : for l in f . readlines (): matrix . append ( # Parse each line as 0's and 1's list ( map ( int , list ( l . strip () . replace ( \".\" , \"0\" ) . replace ( \"#\" , \"1\" )))) ) # Convert to Numpy array matrix = np . array ( matrix ) Part 1 \u00b6 # Repeat horizontally until enough columns (aspect ratio, rounded up at next integer) matrix_reps = np . tile ( matrix , ( 1 , 1 + ( ( 3 * matrix . shape [ 0 ]) // matrix . shape [ 1 ] ))) # Use slices to select every 3rd column; diagonal corresponds to visited squares matrix_reps [ 0 :: 1 , 0 :: 3 ] . diagonal () . sum () 193 Part 2 \u00b6 # Generalising part one with a function def check_slope ( right , down ): matrix_reps = np . tile ( matrix , ( 1 , 1 + (( right * matrix . shape [ 0 ]) // matrix . shape [ 1 ]) )) return matrix_reps [ 0 :: down , 0 :: right ] . diagonal () . sum () slopes = [ ( 1 , 1 ), ( 3 , 1 ), ( 5 , 1 ), ( 7 , 1 ), ( 1 , 2 ) ] # Count the trees encountered with each slope. Cast as uint64 to avoid overflow when calling np.product trees = np . array ([ check_slope ( r , d ) for r , d in slopes ], dtype = 'uint64' ) np . product ( trees ) 1355323200","title":"Day 3"},{"location":"tutorials/day3/#day-3-toboggan-trajectory","text":"","title":"Day 3: Toboggan Trajectory"},{"location":"tutorials/day3/#problem","text":"Note With the toboggan login problems resolved, you set off toward the airport. While travel by toboggan might be easy, it's certainly not safe: there's very minimal steering and the area is covered in trees. You'll need to see which angles will take you near the fewest trees. Due to the local geology, trees in this area only grow on exact integer coordinates in a grid. You make a map (your puzzle input) of the open squares (.) and trees (#) you can see. For example: ..##....... #...#...#.. .#....#..#. ..#.#...#.# .#...##..#. ..#.##..... .#.#.#....# .#........# #.##...#... #...##....# .#..#...#.# These aren't the only trees, though; due to something you read about once involving arboreal genetics and biome stability, the same pattern repeats to the right many times ..##.........##.........##.........##.........##.........##....... ---> #...#...#..#...#...#..#...#...#..#...#...#..#...#...#..#...#...#.. .#....#..#..#....#..#..#....#..#..#....#..#..#....#..#..#....#..#. ..#.#...#.#..#.#...#.#..#.#...#.#..#.#...#.#..#.#...#.#..#.#...#.# .#...##..#..#...##..#..#...##..#..#...##..#..#...##..#..#...##..#. ..#.##.......#.##.......#.##.......#.##.......#.##.......#.##..... ---> .#.#.#....#.#.#.#....#.#.#.#....#.#.#.#....#.#.#.#....#.#.#.#....# .#........#.#........#.#........#.#........#.#........#.#........# #.##...#...#.##...#...#.##...#...#.##...#...#.##...#...#.##...#... #...##....##...##....##...##....##...##....##...##....##...##....# .#..#...#.#.#..#...#.#.#..#...#.#.#..#...#.#.#..#...#.#.#..#...#.# ---> You start on the open square (.) in the top-left corner and need to reach the bottom (below the bottom-most row on your map). The toboggan can only follow a few specific slopes (you opted for a cheaper model that prefers rational numbers); start by counting all the trees you would encounter for the slope right 3, down 1: From your starting position at the top-left, check the position that is right 3 and down 1. Then, check the position that is right 3 and down 1 from there, and so on until you go past the bottom of the map. The locations you'd check in the above example are marked here with O where there was an open square and X where there was a tree: ..##.........##.........##.........##.........##.........##....... ---> #..O#...#..#...#...#..#...#...#..#...#...#..#...#...#..#...#...#.. .#....X..#..#....#..#..#....#..#..#....#..#..#....#..#..#....#..#. ..#.#...#O#..#.#...#.#..#.#...#.#..#.#...#.#..#.#...#.#..#.#...#.# .#...##..#..X...##..#..#...##..#..#...##..#..#...##..#..#...##..#. ..#.##.......#.X#.......#.##.......#.##.......#.##.......#.##..... ---> .#.#.#....#.#.#.#.O..#.#.#.#....#.#.#.#....#.#.#.#....#.#.#.#....# .#........#.#........X.#........#.#........#.#........#.#........# #.##...#...#.##...#...#.X#...#...#.##...#...#.##...#...#.##...#... #...##....##...##....##...#X....##...##....##...##....##...##....# .#..#...#.#.#..#...#.#.#..#...X.#.#..#...#.#.#..#...#.#.#..#...#.# ---> In this example, traversing the map using this slope would cause you to encounter 7 trees. Starting at the top-left corner of your map and following a slope of right 3 and down 1, how many trees would you encounter? https://adventofcode.com/2020/day/3","title":"Problem"},{"location":"tutorials/day3/#solution-1","text":"","title":"Solution 1"},{"location":"tutorials/day3/#tip","text":"You can use numpy here to avoid doing loops. Using For loops here would work, but it would not be scalable when the size of the grid grows. If you apply only numpy vectorization operations, it's a little more complicated but you are almost instantly scalable. import numpy as np","title":"Tip"},{"location":"tutorials/day3/#writing-the-solution-functions","text":"def solve_problem ( text_input : str , slope : tuple ) -> int : # Transform the text input to a list of list of characters text_array = text_input . strip () . split ( \" \\n \" ) text_array = list ( map ( list , text_array )) # Prepare and vectorize the slope with numpy slope = np . array ( slope ) . reshape ( - 1 , 1 ) # Convert to a matrix of 1 and 0s matrix = np . int8 ( np . array ( text_array ) == \"#\" ) # Find the number of iterations to traverse vertically with a given slope iterations = matrix . shape [ 0 ] / slope_coefs [ 0 ] # Directly find the coordinates for each points index = slope * np . arange ( iterations )[ np . newaxis ,:] . repeat ( 2 , axis = 0 ) # As the patterns repeats, we could reproduce the grid horizontally # But algorithmically we can just use division with rest # it will simulate that when you go out of the grid, you reappear to the left index [ 1 ] = index [ 1 ] % matrix . shape [ 1 ] index = index . astype ( int ) # Select directly the cells in the slope selection = matrix [ tuple ( index )] # Sum all values (1s if trees) to get the number on the slope return np . sum ( selection )","title":"Writing the solution functions"},{"location":"tutorials/day3/#solving-the-example","text":"x = \"\"\" ..##.........##.........##.........##.........##.........##....... #...#...#..#...#...#..#...#...#..#...#...#..#...#...#..#...#...#.. .#....#..#..#....#..#..#....#..#..#....#..#..#....#..#..#....#..#. ..#.#...#.#..#.#...#.#..#.#...#.#..#.#...#.#..#.#...#.#..#.#...#.# .#...##..#..#...##..#..#...##..#..#...##..#..#...##..#..#...##..#. ..#.##.......#.##.......#.##.......#.##.......#.##.......#.##..... .#.#.#....#.#.#.#....#.#.#.#....#.#.#.#....#.#.#.#....#.#.#.#....# .#........#.#........#.#........#.#........#.#........#.#........# #.##...#...#.##...#...#.##...#...#.##...#...#.##...#...#.##...#... #...##....##...##....##...##....##...##....##...##....##...##....# .#..#...#.#.#..#...#.#.#..#...#.#.#..#...#.#.#..#...#.#.#..#...#.# \"\"\" print ( x ) text_array = x . strip () . split ( \" \\n \" ) text_array = list ( map ( list , text_array )) ..##.........##.........##.........##.........##.........##....... #...#...#..#...#...#..#...#...#..#...#...#..#...#...#..#...#...#.. .#....#..#..#....#..#..#....#..#..#....#..#..#....#..#..#....#..#. ..#.#...#.#..#.#...#.#..#.#...#.#..#.#...#.#..#.#...#.#..#.#...#.# .#...##..#..#...##..#..#...##..#..#...##..#..#...##..#..#...##..#. ..#.##.......#.##.......#.##.......#.##.......#.##.......#.##..... .#.#.#....#.#.#.#....#.#.#.#....#.#.#.#....#.#.#.#....#.#.#.#....# .#........#.#........#.#........#.#........#.#........#.#........# #.##...#...#.##...#...#.##...#...#.##...#...#.##...#...#.##...#... #...##....##...##....##...##....##...##....##...##....##...##....# .#..#...#.#.#..#...#.#.#..#...#.#.#..#...#.#.#..#...#.#.#..#...#.# matrix = np . int8 ( np . array ( text_array ) == \"#\" ) slope_coefs = ( 1 , 3 ) # numpy is ordered differently slope = np . array ( slope_coefs ) . reshape ( - 1 , 1 ) slope array([[1], [3]]) iterations = matrix . shape [ 0 ] / slope_coefs [ 0 ] iterations 11.0 index = slope * np . arange ( iterations )[ np . newaxis ,:] . repeat ( 2 , axis = 0 ) index [ 1 ] = index [ 1 ] % matrix . shape [ 1 ] index = index . astype ( int ) index array([[ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [ 0, 3, 6, 9, 12, 15, 18, 21, 24, 27, 30]]) selection = matrix [ tuple ( index )] np . sum ( selection ) 7 Or using the function solve_problem ( x ,( 1 , 3 )) 7","title":"Solving the example"},{"location":"tutorials/day3/#solving-the-final-solution","text":"text_input = open ( \"inputs/day3.txt\" , \"r\" ) . read () print ( text_input [: 500 ]) .#..............##....#.#.####. ##..........#.....##........... .......#....##...........#.#... .........#.#...#..........#.... .........#..#................## ..#...#..#..#...........#...... ...................#...##..##.. ........#.....##...#.#.#...#... #..#.##......#.#..#..........#. ......#.#...#.#...#........##.# .....#.####........#........... ...###..#............#......... .....#.......##......#...#..... #......##...................... ......#..............#......... ..##...#....###.##.. solve_problem ( text_input ,( 1 , 3 )) 193","title":"Solving the final solution"},{"location":"tutorials/day3/#solution-2","text":"import numpy as np # Load matrix from file matrix = [] with open ( 'inputs/day3.txt' , 'r' ) as f : for l in f . readlines (): matrix . append ( # Parse each line as 0's and 1's list ( map ( int , list ( l . strip () . replace ( \".\" , \"0\" ) . replace ( \"#\" , \"1\" )))) ) # Convert to Numpy array matrix = np . array ( matrix )","title":"Solution 2"},{"location":"tutorials/day3/#part-1","text":"# Repeat horizontally until enough columns (aspect ratio, rounded up at next integer) matrix_reps = np . tile ( matrix , ( 1 , 1 + ( ( 3 * matrix . shape [ 0 ]) // matrix . shape [ 1 ] ))) # Use slices to select every 3rd column; diagonal corresponds to visited squares matrix_reps [ 0 :: 1 , 0 :: 3 ] . diagonal () . sum () 193","title":"Part 1"},{"location":"tutorials/day3/#part-2","text":"# Generalising part one with a function def check_slope ( right , down ): matrix_reps = np . tile ( matrix , ( 1 , 1 + (( right * matrix . shape [ 0 ]) // matrix . shape [ 1 ]) )) return matrix_reps [ 0 :: down , 0 :: right ] . diagonal () . sum () slopes = [ ( 1 , 1 ), ( 3 , 1 ), ( 5 , 1 ), ( 7 , 1 ), ( 1 , 2 ) ] # Count the trees encountered with each slope. Cast as uint64 to avoid overflow when calling np.product trees = np . array ([ check_slope ( r , d ) for r , d in slopes ], dtype = 'uint64' ) np . product ( trees ) 1355323200","title":"Part 2"},{"location":"tutorials/quickstart/","text":"","title":"Quickstart"}]}